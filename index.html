import React, { useRef, useEffect } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

export default function VideoCube() {
  const mountRef = useRef(null);
  const videoRefs = useRef([]);

  useEffect(() => {
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    mountRef.current.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableZoom = false;
    controls.enablePan = false;
    controls.rotateSpeed = 0.8;
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;

    const geometry = new THREE.BoxGeometry(2, 2, 2);
    const videoSources = [
      'https://www.w3schools.com/html/mov_bbb.mp4',
      'https://samplelib.com/lib/preview/mp4/sample-5s.mp4',
      'https://media.w3.org/2010/05/sintel/trailer.mp4',
      'https://media.w3.org/2010/05/bunny/trailer.mp4',
      'https://media.w3.org/2010/05/video/movie_300.mp4',
      'https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4'
    ];

    const videoElements = videoSources.map((src, i) => {
      const video = document.createElement('video');
      video.src = src;
      video.crossOrigin = 'anonymous';
      video.loop = true;
      video.muted = true;
      video.playsInline = true;
      video.load();
      videoRefs.current.push(video);
      return video;
    });

    const materials = videoElements.map((video) => {
      const texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.format = THREE.RGBFormat;
      return new THREE.MeshBasicMaterial({ map: texture });
    });

    const cube = new THREE.Mesh(geometry, materials);
    scene.add(cube);

    const animate = () => {
      requestAnimationFrame(animate);
      controls.update();
      updateVideoPlayback(camera, cube);
      renderer.render(scene, camera);
    };

    animate();

    return () => {
      mountRef.current.removeChild(renderer.domElement);
      videoRefs.current.forEach(video => video.pause());
    };
  }, []);

  const updateVideoPlayback = (camera, cube) => {
    let maxDot = -Infinity;
    let frontFaceIndex = -1;

    const faceNormals = [
      new THREE.Vector3(1, 0, 0),
      new THREE.Vector3(-1, 0, 0),
      new THREE.Vector3(0, 1, 0),
      new THREE.Vector3(0, -1, 0),
      new THREE.Vector3(0, 0, 1),
      new THREE.Vector3(0, 0, -1)
    ];

    faceNormals.forEach((normal, index) => {
      const rotatedNormal = normal.clone().applyQuaternion(cube.quaternion);
      const dot = rotatedNormal.dot(camera.getWorldDirection(new THREE.Vector3()));
      if (dot > maxDot) {
        maxDot = dot;
        frontFaceIndex = index;
      }
    });

    videoRefs.current.forEach((video, index) => {
      if (index === frontFaceIndex) {
        if (video.paused) {
          video.muted = false;
          video.play();
        }
      } else {
        if (!video.paused) {
          video.pause();
        }
        video.muted = true;
      }
    });
  };

  return <div ref={mountRef} style={{ width: '100vw', height: '100vh' }} />;
}
